double cast_ray(t_data *data, double ray_angle)
{
    init_dda(data, ray_angle);

    // Déterminer le pas et la distance initiale
    int step_x, step_y;
    double side_dist_x, side_dist_y;

    if (data->dda->ray_dir_x < 0)
    {
        step_x = -1;
        side_dist_x = (data->dda->x_start / T_SIZE - data->dda->map_x) * data->dda->delta_dist_x;
    }
    else
    {
        step_x = 1;
        side_dist_x = (data->dda->map_x + 1.0 - data->dda->x_start / T_SIZE) * data->dda->delta_dist_x;
    }

    if (data->dda->ray_dir_y < 0)
    {
        step_y = -1;
        side_dist_y = (data->dda->y_start / T_SIZE - data->dda->map_y) * data->dda->delta_dist_y;
    }
    else
    {
        step_y = 1;
        side_dist_y = (data->dda->map_y + 1.0 - data->dda->y_start / T_SIZE) * data->dda->delta_dist_y;
    }

    // Exécuter l'algorithme DDA
    int hit = 0;  // Collision avec un mur?
    int side;     // Mur touché est NS ou EW?

    while (hit == 0)
    {
        // Avancer au prochain carré de la carte
        if (side_dist_x < side_dist_y)
        {
            side_dist_x += data->dda->delta_dist_x;
            data->dda->map_x += step_x;
            side = 0;  // Touché un mur vertical
        }
        else
        {
            side_dist_y += data->dda->delta_dist_y;
            data->dda->map_y += step_y;
            side = 1;  // Touché un mur horizontal
        }

        // Vérifier si on a touché un mur
        if (data->copy_map[data->dda->map_y][data->dda->map_x] == '1')
            hit = 1;
    }

    // Calculer la distance perpendiculaire au plan de caméra
    double wall_dist;
    if (side == 0)
        wall_dist = (data->dda->map_x - data->dda->x_start / T_SIZE +
            (1 - step_x) / 2) / data->dda->ray_dir_x;
    else
        wall_dist = (data->dda->map_y - data->dda->y_start / T_SIZE +
            (1 - step_y) / 2) / data->dda->ray_dir_y;

    // Stocker l'information sur le mur touché pour la texture
    data->dda->hit_side = side;
    data->dda->hit_x = data->dda->map_x;
    data->dda->hit_y = data->dda->map_y;

    return wall_dist * T_SIZE;  // Distance en pixels
}

 À quoi ça sert de retourner un double ?

R: Dans un algorithme DDA pour un raycaster, retourner un double depuis la fonction dda_cast() sert principalement à renvoyer la distance précise entre le joueur et le point d'impact du rayon sur un mur.

Cette distance en valeur décimale est essentielle pour plusieurs raisons:

Calcul de hauteur des murs La valeur précise permet de calculer exactement la hauteur à laquelle dessiner le mur à l'écran:
int wall_height = (int)(SCREEN_HEIGHT / wall_distance);
Éviter l'effet "fisheye" La distance précise permet d'appliquer des corrections mathématiques pour éviter l'effet de distorsion (fisheye).

Ombrage et effets visuels Les effets comme le fog (brouillard de distance) nécessitent des valeurs de distance précises.

Texture mapping Pour mapper correctement les textures sur les murs, vous avez besoin de la position exacte d'impact.

Un double offre la précision nécessaire pour ces calculs, alors qu'un int pourrait introduire des erreurs d'arrondi qui affecteraient la qualité visuelle du rendu.
